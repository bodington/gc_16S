#' Cluster ASVs in a sequence table into OTUs
#'
#' Takes the ASV sequence table generated by DADA2 (seqtab) or phyloseq and clusters OTUs
#' 
#' @param seqtab A sequence table eg. generated by dada2
#' @param similarity OTU clustering distance (%)
#' @param nproc Number of processors
#' 
#' @details Filler
#' @return A clustered sequence table
#' @export
#' @importFrom Biostrings DNAStringSet
#' @importFrom DECIPHER AlignSeqs
#' @importFrom DECIPHER TreeLine
#' @examples
#' \dontrun{
#' clustered.seqtab <- cluster_asv_dada2(asv.seqtab)
#' }##
cluster_asv_dada2 <- function(seqtab,
                              similarity = 99,
                              nproc = 4) {
  asv_sequences <- colnames(seqtab)
  dna <- Biostrings::DNAStringSet(asv_sequences)
  aln <- DECIPHER::AlignSeqs(dna, processors = nproc)
  d <- DECIPHER::DistanceMatrix(aln, processors = nproc)
  clusters <- DECIPHER::TreeLine(
    myDistMatrix = d,
    method = "complete",
    cutoff = 1 - similarity / 100,
    type = "clusters",
    processors = nproc
  )
  clusters <- clusters %>%
    add_column(sequence = asv_sequences)
  seqtab_clustered <- seqtab %>%
    t %>%
    rowsum(clusters$cluster) %>%
    t
  return(seqtab_clustered)
}


#' Cluster ASVs in a phyloseq objext into OTUs
#'
#' Takes a phyloseq object with sequence data and clusters ASVs to OTUs
#' 
#' @param ps A phyloseq object
#' @param similarity OTU clustering distance (%)
#' @param nproc Number of processors
#' 
#' @details Filler
#' @return A phyloseq object with OTUs at a set similarity
#' @export
#' @importFrom phyloseq refseq
#' @importFrom DECIPHER AlignSeqs
#' @importFrom DECIPHER TreeLine
#' @importFrom speedyseq merge_taxa_vec
#' @examples
#' \dontrun{
#' clustered.seqtab <- cluster_asv_dada2(asv.seqtab)
#' }##
cluster_asv_phyloseq <- function(ps,
                                 similarity = 99,
                                 nproc = 4) {
  dna <- refseq(ps)
  aln <- DECIPHER::AlignSeqs(dna, processors = nproc)
  d <- DECIPHER::DistanceMatrix(aln, processors = nproc)
  clusters <- DECIPHER::TreeLine(
    myDistMatrix = d,
    method = "complete",
    cutoff = 1 - similarity / 100,
    type = "clusters",
    processors = nproc
  )
  ps <-
    speedyseq::merge_taxa_vec(ps, group = clusters$cluster, tax_adjust = 2)
  taxa_names(ps) <- paste0("OTU", seq(ntaxa(ps)))
  return(ps)
}


#' Classify a phyloseq object with decipher
#'
#' Assigns taxonomy to a phyloseq objext using decipher, and returns the tax table
#' 
#' @param ps A phyloseq object
#' @details The sequence table is assigned taxonomy using DECIPHER with the
#' @details greengenes or GTDB training set. (Ranks: D;P;C;O;F;G;S)
#' @return A tax table for importing into a phyloseq object
#' @export
#' @import phyloseq
#' @importFrom DECIPHER IdTaxa
#' @examples
#' \dontrun{
#' tax_table(phyloseq_project) <- phyloseq_decipher_tax(phyloseq_project, tax_file)
#' }
phyloseq_decipher_tax <- function(ps, tax_file) {
  load(tax_file)
  dna <- refseq(ps)
  ids <- IdTaxa(dna,
    trainingSet,
    strand="top",
    processors=8,
    verbose=FALSE
    )
  ranks <- c("domain", "phylum", "class", "order", "family", "genus", "species")
  taxid <- t(sapply(
              ids,
              function(x) {
                m <- match(ranks, x$rank)
                taxa <- x$taxon[m]
                taxa[startsWith(taxa, "unclassified_")] <- NA
                taxa
                }
              )
            )
  colnames(taxid) <- ranks
  rownames(taxid) <- names(dna)
  # Return the tax table for merging into a phyloseq objext
  return(tax_table(taxid))
  }


#' Cleanly merge (using sequence as ASV name) phyloseq objects in a list
phyloseq_clean_merge <- function(phyloseq_list) {
  do.call(
    merge_phyloseq,
    lapply(
      phyloseq_list,
      function(x) {
        taxa_names(x) <- as.character(refseq(x), use.names = FALSE)
        return(x)
        }
      )     
    )
  }


#' Root Tree in phyloseq Object
#'
#' Roots an unrooted tree in a phyloseq object
#' 
#' @param ps A phyloseq object containing an unrooted tree
#' @details The tree is rooted by the longest terminal branch.
#' @return The same phyloseq object with a rooted tree
#' @export
#' @importFrom ape Ntip
#' @importFrom magrittr %>%
#' @importFrom data.table data.table
#' @examples
#' \dontrun{
#' expt.rooted <- root_phyloseq_tree(expt.unrooted)
#' }
phyloseq_root_tree <- function(ps) {
  tree.unrooted <- phy_tree(ps)
  # tablify parts of tree that we need.
  treeDT <-
    cbind(
      data.table(tree.unrooted$edge),
      data.table(length = tree.unrooted$edge.length)
    )[1:Ntip(tree.unrooted)] %>%
    cbind(data.table(id = tree.unrooted$tip.label))
  # Take the longest terminal branch as outgroup
  new.outgroup <- treeDT[which.max(length)]$id
  new.tree <- ape::root(tree.unrooted, outgroup = new.outgroup, resolve.root = TRUE)
  phy_tree(ps) <- new.tree
  return(ps)
}


## Replace missing taxonomy in a phyloseq object
phyloseq_taxonomy_imputation <- function(ps,
                                         unknown_taxon = "_unidentified",
                                         unknown_sp = " sp",
                                         make_unique = FALSE,
                                         addmaxrank = FALSE) {
  ## If input is of class 'phyloseq'
  inp_class <- class(ps)
  if ("phyloseq" %in% inp_class || "taxonomyTable" %in% inp_class) {
    if (is.null(phyloseq::tax_table(ps, errorIfNULL = F))) {
      stop("Error: taxonomy table slot is empty in the input data.\n")
    }
    
    x <-
      as.data.frame(phyloseq::tax_table(ps), stringsAsFactors = F)
  } else {
    stop("Error: input data should be of class `phyloseq` or `taxonomyTable`")
  }
  
  ## Function to replace NAs with higher taxa names + unident string
  replace_col <- function(x,
                          col_num = 2,
                          unident = "unidentified") {
    nas <- is.na(x[, col_num])
    if (any(nas) == FALSE) {
      return(x)              # no missing values
    } else {
      ## which values to replace
      to_repl <- which(nas)
      
      if (col_num == 1) {
        x[to_repl, col_num] <- unident
      } else {
        x[to_repl, col_num] <-
          paste(x[to_repl, col_num - 1], unident, sep = "")
      }
      return(x)
    }
  }
  
  clz <- colnames(x)
  sp_in_ranks <- clz %in% c("Species", "species", "sp")
  if (any(sp_in_ranks)) {
    sp_id <- which(sp_in_ranks)
    non_sp_id <- (1:length(clz))[-sp_id]
  } else {
    sp_id <- NA
    non_sp_id <- 1:length(clz)
  }
  
  ## Replace higher taxa
  for (i in non_sp_id) {
    x <- replace_col(x, col_num = i, unident = unknown_taxon)
  }
  
  ## Replace species names
  if (!is.na(sp_id)) {
    x <- replace_col(x, col_num = sp_id, unident = unknown_sp)
  }
  
  ## Function to remove multiple unident strings (e.g., "_unidentified_unidentified")
  replace_unidents <-
    function(tt, strr = "_unidentified", spp = " sp") {
      ## tt = character vector
      
      ## Prepare regex for paterns
      # Multiple string occurrences
      multpatt <- paste("(", strr, ")(\\1+)", sep = "")
      unsp <- paste(strr, spp, sep = "")
      
      ## Replace "_unidetified_unidentified" with single occurrence
      # gsub(x = tt, pattern = "(_unidentified)(\\1+)", replacement = "_unidentified", perl = T)
      rez <-
        gsub(
          x = tt,
          pattern = multpatt,
          replacement = strr,
          perl = T
        )
      
      ## Replace "_unidetified sp" with " sp"
      rez <-
        gsub(
          x = rez,
          pattern = unsp,
          replacement = spp,
          perl = T
        )
      
      return(rez)
    }
  
  ## Remove multiple unident strings from all tax columns
  x <- sapply(x, replace_unidents)
  
  ## Make species names unique
  if (make_unique == TRUE) {
    x[, ncol(x)] <- base::make.unique(names = x[, ncol(x)], sep = ".")
  }
  
  ## Add the OTU classification at the lowest annotated taxonomic rank
  if (addmaxrank == TRUE) {
    LowestTaxRank <-
      as.character(get_max_taxonomic_rank(ps, return_rank_only = TRUE))
    x <- cbind(x, LowestTaxRank = LowestTaxRank)
  }
  
  ## Add taxa names
  rownames(x) <- phyloseq::taxa_names(ps)
  
  ## Replace tax_table with the modified one
  phyloseq::tax_table(ps) <- phyloseq::tax_table(as.matrix(x))
  return(ps)
}


#' Formats the sequence table from a phyloseq object
format_asv_table <- function(ps) {
  if (as.logical(class(phyloseq::otu_table(ps))[1] == "otu_table") &&
      as.logical(taxa_are_rows(phyloseq::otu_table(ps)) == TRUE)) {
    asv_tab <- as.matrix(phyloseq::otu_table(ps))
  } else {
    asv_tab <- as.matrix(t(phyloseq::otu_table(ps)))
  }
  return(asv_tab)
}


#' Exports a biom file from a phyloseq object
phyloseq_write_dataset_biom <- function(
                                  ps,
                                  filePATH,
                                  filePREFIX,
                                  writeFASTA = TRUE,
                                  rename = FALSE,
                                  useREFSEQ = TRUE) {
    #pull seqs from refseq slot or extract from ASV ID for fasta format
    if (isTRUE(useREFSEQ)) {
      #from phyloseq refseq slot
      f.onames <- phyloseq::refseq(ps)
    } else {
      f.onames <- phyloseq::taxa_names(ps)
    }
    
    if (isTRUE(rename)) {
      phyloseq::taxa_names(ps) <-
        paste("ASV", 1:length(phyloseq::taxa_names(ps)), sep = "")
      names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
    } else {
      names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
    }
    
    #generate biom file
    suppressWarnings(
      ps.b <- biomformat::make_biom(
        data = format_asv_table(ps),
        sample_metadata = as.data.frame(phyloseq::sample_data(ps)),
        observation_metadata = as.data.frame(phyloseq::tax_table(ps)),
        matrix_element_type = "int"
      )
    )
    
    #create output string
    if (isTRUE(writeFASTA)) {
      fa <- print(paste0(filePATH, filePREFIX, "_ASVs.fasta"))
    }
    bo <- print(paste0(filePATH, filePREFIX, "_ASV_table.biom"))
    
    #write output
    if (isTRUE(writeFASTA)) {
      write.table(
        x = f.onames,
        file = fa,
        quote = FALSE,
        sep = "\n",
        col.names = FALSE
      )
    }
    #biom export
    biomformat::write_biom(x = ps.b, biom_file = bo)
    
    #return phyloseq object with taxa renamed to ASV1, etc., if desired
    if (isTRUE(rename)) {
      return(ps)
    }
  }

  
#' Exports the sequence table and fasta file from a phyloseq object
phyloseq_write_dataset <- function(
                            ps,
                            filePATH,
                            filePREFIX,
                            writeFASTA = TRUE,
                            rename = FALSE,
                            useREFSEQ = TRUE) {
    #pull seqs from refseq slot or extract from ASV ID for fasta format
    if (isTRUE(useREFSEQ)) {
      #from phyloseq refseq slot
      f.onames <- phyloseq::refseq(ps)
    } else {
      f.onames <- phyloseq::taxa_names(ps)
    }
    
    if (isTRUE(rename)) {
      phyloseq::taxa_names(ps) <-
        paste("ASV", 1:length(phyloseq::taxa_names(ps)), sep = "")
      names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
    } else {
      names(f.onames) <- paste0(">", phyloseq::taxa_names(ps))
    }
    
    
    #generate asv table formatted for biom generation
    asv_tab <- format_asv_table(ps)
    suppressWarnings(asv_tab <- as.matrix(asv_tab))
    cb <- as.matrix(cbind(rownames(asv_tab), asv_tab))
    rcb <- as.matrix(rbind(colnames(cb), cb))
    rcb[1, 1] <- "#ASVID"
    rownames(rcb) <- NULL
    colnames(rcb) <- NULL
    
    #generate tax table formatted for biom generation
    tax.tab <- as.data.frame(phyloseq::tax_table(ps))
    tax.tab$taxonomy <-
      tidyr::unite(tax.tab, "out", c(colnames(tax.tab)), sep = ";")
    cbt <- as.matrix(cbind(rownames(tax.tab), tax.tab$taxonomy))
    rcbt <- as.matrix(rbind(c("#ASVID", "taxonomy"), cbt))
    rownames(cbt) <- NULL
    colnames(cbt) <- NULL
    
    #generate sampledf table formatted for biom generation
    samdf <- suppressWarnings(as.matrix(phyloseq::sample_data(ps)))
    cbs <- as.matrix(cbind(rownames(samdf), samdf))
    rcbs <- as.matrix(rbind(colnames(cbs), cbs))
    rcbs[1, 1] <- "#SampleID"
    rownames(rcbs) <- NULL
    colnames(rcbs) <- NULL
    
    #create output string
    if (isTRUE(writeFASTA)) {
      fa <- print(paste0(filePATH, filePREFIX, "_ASVs.fasta"))
    }
    otb <- print(paste0(filePATH, filePREFIX, "_ASV_table.txt"))
    ttb <- print(paste0(filePATH, filePREFIX, "_ASV_taxonomy.txt"))
    stb <- print(paste0(filePATH, filePREFIX, "_sample_data.txt"))
    
    
    #write output
    #ASV fasta
    if (isTRUE(writeFASTA)) {
      write.table(
        x = f.onames,
        file = fa,
        quote = FALSE,
        sep = "\n",
        col.names = FALSE
      )
    }
    #asv_tab
    write.table(
      x = rcb,
      file = otb,
      row.names = FALSE,
      col.names = FALSE,
      quote = FALSE,
      sep = "\t"
    )
    #tax.tab
    write.table(
      x = rcbt,
      file = ttb,
      row.names = FALSE,
      col.names = FALSE,
      quote = FALSE,
      sep = "\t"
    )
    #sampledf
    write.table(
      x = rcbs,
      file = stb,
      row.names = FALSE,
      col.names = FALSE,
      quote = FALSE,
      sep = "\t"
    )
    
    #return phyloseq object with taxa renamed to ASV1, etc., if desired
    if (isTRUE(rename)) {
      return(ps)
    }
  }